// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: roles.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreateRolesParams struct {
	ID            pgtype.UUID `json:"id"`
	TitleRu       string      `json:"title_ru"`
	TitleEn       pgtype.Text `json:"title_en"`
	TitleKk       pgtype.Text `json:"title_kk"`
	DescriptionRu string      `json:"description_ru"`
	DescriptionEn pgtype.Text `json:"description_en"`
	DescriptionKk pgtype.Text `json:"description_kk"`
	Value         string      `json:"value"`
}

const bulkDeleteRoleByIds = `-- name: BulkDeleteRoleByIds :many
UPDATE roles
SET deleted_at = now(),
    updated_at = now()
WHERE id = ANY($1::uuid[]) AND deleted_at IS NULL
RETURNING id, title_ru, title_en, title_kk, description_ru, description_kk, description_en, value, created_at, updated_at, deleted_at
`

func (q *Queries) BulkDeleteRoleByIds(ctx context.Context, dollar_1 []pgtype.UUID) ([]Role, error) {
	rows, err := q.db.Query(ctx, bulkDeleteRoleByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.TitleRu,
			&i.TitleEn,
			&i.TitleKk,
			&i.DescriptionRu,
			&i.DescriptionKk,
			&i.DescriptionEn,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bulkHardDeleteRoleByIds = `-- name: BulkHardDeleteRoleByIds :exec
DELETE FROM roles
WHERE id = ANY($1::uuid[])
`

func (q *Queries) BulkHardDeleteRoleByIds(ctx context.Context, dollar_1 []pgtype.UUID) error {
	_, err := q.db.Exec(ctx, bulkHardDeleteRoleByIds, dollar_1)
	return err
}

const countAllRoles = `-- name: CountAllRoles :one
SELECT COUNT(DISTINCT r.id)
FROM roles r
WHERE
    -- show_deleted filter
    (CASE WHEN $1::boolean THEN TRUE ELSE r.deleted_at IS NULL END)
    -- search filter
    AND (
        $2::text IS NULL OR
        r.title_ru ILIKE '%' || $2 || '%' OR
        r.title_en ILIKE '%' || $2 || '%' OR
        r.title_kk ILIKE '%' || $2 || '%' OR
        r.description_ru ILIKE '%' || $2 || '%' OR
        r.description_en ILIKE '%' || $2 || '%' OR
        r.description_kk ILIKE '%' || $2 || '%' OR
        r.value ILIKE '%' || $2 || '%'
    )
    -- values filter
    AND (
        $3::text[] IS NULL OR
        r.value = ANY($3::text[])
    )
    -- ids filter
    AND (
        $4::uuid[] IS NULL OR
        r.id = ANY($4::uuid[])
    )
`

type CountAllRolesParams struct {
	ShowDeleted pgtype.Bool   `json:"show_deleted"`
	Search      pgtype.Text   `json:"search"`
	Values      []string      `json:"values"`
	Ids         []pgtype.UUID `json:"ids"`
}

func (q *Queries) CountAllRoles(ctx context.Context, arg CountAllRolesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllRoles,
		arg.ShowDeleted,
		arg.Search,
		arg.Values,
		arg.Ids,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOneRole = `-- name: CreateOneRole :one

INSERT INTO roles (id, title_ru, title_en, title_kk, description_ru, description_en, description_kk, value)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, title_ru, title_en, title_kk, description_ru, description_kk, description_en, value, created_at, updated_at, deleted_at
`

type CreateOneRoleParams struct {
	ID            pgtype.UUID `json:"id"`
	TitleRu       string      `json:"title_ru"`
	TitleEn       pgtype.Text `json:"title_en"`
	TitleKk       pgtype.Text `json:"title_kk"`
	DescriptionRu string      `json:"description_ru"`
	DescriptionEn pgtype.Text `json:"description_en"`
	DescriptionKk pgtype.Text `json:"description_kk"`
	Value         string      `json:"value"`
}

// ============================================================================
// BASIC CRUD OPERATIONS
// ============================================================================
func (q *Queries) CreateOneRole(ctx context.Context, arg CreateOneRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, createOneRole,
		arg.ID,
		arg.TitleRu,
		arg.TitleEn,
		arg.TitleKk,
		arg.DescriptionRu,
		arg.DescriptionEn,
		arg.DescriptionKk,
		arg.Value,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.TitleRu,
		&i.TitleEn,
		&i.TitleKk,
		&i.DescriptionRu,
		&i.DescriptionKk,
		&i.DescriptionEn,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteRoleById = `-- name: DeleteRoleById :one
UPDATE roles
SET deleted_at = now(),
    updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title_ru, title_en, title_kk, description_ru, description_kk, description_en, value, created_at, updated_at, deleted_at
`

func (q *Queries) DeleteRoleById(ctx context.Context, id pgtype.UUID) (Role, error) {
	row := q.db.QueryRow(ctx, deleteRoleById, id)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.TitleRu,
		&i.TitleEn,
		&i.TitleKk,
		&i.DescriptionRu,
		&i.DescriptionKk,
		&i.DescriptionEn,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getRoleById = `-- name: GetRoleById :one
SELECT r.id, r.title_ru, r.title_en, r.title_kk, r.description_ru, r.description_kk, r.description_en, r.value, r.created_at, r.updated_at, r.deleted_at,
       COALESCE(
           json_agg(
               json_build_object(
                   'id', p.id,
                   'title_ru', p.title_ru,
                   'title_en', p.title_en,
                   'title_kk', p.title_kk,
                   'value', p.value,
                   'description_ru', p.description_ru,
                   'description_en', p.description_en,
                   'description_kk', p.description_kk,
                   'created_at', p.created_at,
                   'updated_at', p.updated_at,
                   'deleted_at', p.deleted_at
               )
           ) FILTER (WHERE p.id IS NOT NULL), '[]'
       ) as permissions
FROM roles r
LEFT JOIN role_permissions rp ON r.id = rp.role_id
LEFT JOIN permissions p ON rp.permission_id = p.id AND p.deleted_at IS NULL
WHERE r.id = $1 AND r.deleted_at IS NULL
GROUP BY r.id
`

type GetRoleByIdRow struct {
	ID            pgtype.UUID      `json:"id"`
	TitleRu       string           `json:"title_ru"`
	TitleEn       pgtype.Text      `json:"title_en"`
	TitleKk       pgtype.Text      `json:"title_kk"`
	DescriptionRu string           `json:"description_ru"`
	DescriptionKk pgtype.Text      `json:"description_kk"`
	DescriptionEn pgtype.Text      `json:"description_en"`
	Value         string           `json:"value"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	DeletedAt     pgtype.Timestamp `json:"deleted_at"`
	Permissions   interface{}      `json:"permissions"`
}

func (q *Queries) GetRoleById(ctx context.Context, id pgtype.UUID) (GetRoleByIdRow, error) {
	row := q.db.QueryRow(ctx, getRoleById, id)
	var i GetRoleByIdRow
	err := row.Scan(
		&i.ID,
		&i.TitleRu,
		&i.TitleEn,
		&i.TitleKk,
		&i.DescriptionRu,
		&i.DescriptionKk,
		&i.DescriptionEn,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Permissions,
	)
	return i, err
}

const getRoleByValue = `-- name: GetRoleByValue :one
SELECT r.id, r.title_ru, r.title_en, r.title_kk, r.description_ru, r.description_kk, r.description_en, r.value, r.created_at, r.updated_at, r.deleted_at,
       COALESCE(
           json_agg(
               json_build_object(
                   'id', p.id,
                   'title_ru', p.title_ru,
                   'title_en', p.title_en,
                   'title_kk', p.title_kk,
                   'value', p.value,
                   'description_ru', p.description_ru,
                   'description_en', p.description_en,
                   'description_kk', p.description_kk,
                   'created_at', p.created_at,
                   'updated_at', p.updated_at,
                   'deleted_at', p.deleted_at
               )
           ) FILTER (WHERE p.id IS NOT NULL), '[]'
       ) as permissions
FROM roles r
LEFT JOIN role_permissions rp ON r.id = rp.role_id
LEFT JOIN permissions p ON rp.permission_id = p.id AND p.deleted_at IS NULL
WHERE r.value = $1 AND r.deleted_at IS NULL
GROUP BY r.id
`

type GetRoleByValueRow struct {
	ID            pgtype.UUID      `json:"id"`
	TitleRu       string           `json:"title_ru"`
	TitleEn       pgtype.Text      `json:"title_en"`
	TitleKk       pgtype.Text      `json:"title_kk"`
	DescriptionRu string           `json:"description_ru"`
	DescriptionKk pgtype.Text      `json:"description_kk"`
	DescriptionEn pgtype.Text      `json:"description_en"`
	Value         string           `json:"value"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	DeletedAt     pgtype.Timestamp `json:"deleted_at"`
	Permissions   interface{}      `json:"permissions"`
}

func (q *Queries) GetRoleByValue(ctx context.Context, value string) (GetRoleByValueRow, error) {
	row := q.db.QueryRow(ctx, getRoleByValue, value)
	var i GetRoleByValueRow
	err := row.Scan(
		&i.ID,
		&i.TitleRu,
		&i.TitleEn,
		&i.TitleKk,
		&i.DescriptionRu,
		&i.DescriptionKk,
		&i.DescriptionEn,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Permissions,
	)
	return i, err
}

const getRoleWithPermissions = `-- name: GetRoleWithPermissions :one

SELECT r.id, r.title_ru, r.title_en, r.title_kk, r.description_ru, r.description_kk, r.description_en, r.value, r.created_at, r.updated_at, r.deleted_at,
       COALESCE(
           json_agg(
               json_build_object(
                   'id', p.id,
                   'title_ru', p.title_ru,
                   'title_en', p.title_en,
                   'title_kk', p.title_kk,
                   'value', p.value,
                   'description_ru', p.description_ru,
                   'description_en', p.description_en,
                   'description_kk', p.description_kk
               )
           ) FILTER (WHERE p.id IS NOT NULL), '[]'
       ) as permissions
FROM roles r
LEFT JOIN role_permissions rp ON r.id = rp.role_id
LEFT JOIN permissions p ON rp.permission_id = p.id AND p.deleted_at IS NULL
WHERE r.id = $1 AND r.deleted_at IS NULL
GROUP BY r.id
`

type GetRoleWithPermissionsRow struct {
	ID            pgtype.UUID      `json:"id"`
	TitleRu       string           `json:"title_ru"`
	TitleEn       pgtype.Text      `json:"title_en"`
	TitleKk       pgtype.Text      `json:"title_kk"`
	DescriptionRu string           `json:"description_ru"`
	DescriptionKk pgtype.Text      `json:"description_kk"`
	DescriptionEn pgtype.Text      `json:"description_en"`
	Value         string           `json:"value"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	DeletedAt     pgtype.Timestamp `json:"deleted_at"`
	Permissions   interface{}      `json:"permissions"`
}

// ============================================================================
// LEGACY QUERIES (For backward compatibility)
// ============================================================================
func (q *Queries) GetRoleWithPermissions(ctx context.Context, id pgtype.UUID) (GetRoleWithPermissionsRow, error) {
	row := q.db.QueryRow(ctx, getRoleWithPermissions, id)
	var i GetRoleWithPermissionsRow
	err := row.Scan(
		&i.ID,
		&i.TitleRu,
		&i.TitleEn,
		&i.TitleKk,
		&i.DescriptionRu,
		&i.DescriptionKk,
		&i.DescriptionEn,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Permissions,
	)
	return i, err
}

const hardDeleteRoleById = `-- name: HardDeleteRoleById :exec
DELETE FROM roles
WHERE id = $1
`

func (q *Queries) HardDeleteRoleById(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteRoleById, id)
	return err
}

const listAllRoles = `-- name: ListAllRoles :many

SELECT r.id, r.title_ru, r.title_en, r.title_kk, r.description_ru, r.description_kk, r.description_en, r.value, r.created_at, r.updated_at, r.deleted_at,
       COALESCE(
           json_agg(
               json_build_object(
                   'id', p.id,
                   'title_ru', p.title_ru,
                   'title_en', p.title_en,
                   'title_kk', p.title_kk,
                   'value', p.value,
                   'description_ru', p.description_ru,
                   'description_en', p.description_en,
                   'description_kk', p.description_kk,
                   'created_at', p.created_at,
                   'updated_at', p.updated_at,
                   'deleted_at', p.deleted_at
               )
           ) FILTER (WHERE p.id IS NOT NULL), '[]'
       ) as permissions
FROM roles r
LEFT JOIN role_permissions rp ON r.id = rp.role_id
LEFT JOIN permissions p ON rp.permission_id = p.id AND p.deleted_at IS NULL
WHERE
    -- show_deleted filter
    (CASE WHEN $1::boolean THEN TRUE ELSE r.deleted_at IS NULL END)
    -- search filter (title_ru, title_en, title_kk, description_ru, description_en, description_kk, value)
    AND (
        $2::text IS NULL OR
        r.title_ru ILIKE '%' || $2 || '%' OR
        r.title_en ILIKE '%' || $2 || '%' OR
        r.title_kk ILIKE '%' || $2 || '%' OR
        r.description_ru ILIKE '%' || $2 || '%' OR
        r.description_en ILIKE '%' || $2 || '%' OR
        r.description_kk ILIKE '%' || $2 || '%' OR
        r.value ILIKE '%' || $2 || '%'
    )
    -- values filter
    AND (
        $3::text[] IS NULL OR
        r.value = ANY($3::text[])
    )
    -- ids filter
    AND (
        $4::uuid[] IS NULL OR
        r.id = ANY($4::uuid[])
    )
GROUP BY r.id
ORDER BY
    CASE WHEN $5 = 'created_at' AND $6 = 'ASC' THEN r.created_at END ASC,
    CASE WHEN $5 = 'created_at' AND $6 = 'DESC' THEN r.created_at END DESC,
    CASE WHEN $5 = 'updated_at' AND $6 = 'ASC' THEN r.updated_at END ASC,
    CASE WHEN $5 = 'updated_at' AND $6 = 'DESC' THEN r.updated_at END DESC,
    CASE WHEN $5 = 'title_ru' AND $6 = 'ASC' THEN r.title_ru END ASC,
    CASE WHEN $5 = 'title_ru' AND $6 = 'DESC' THEN r.title_ru END DESC,
    CASE WHEN $5 = 'value' AND $6 = 'ASC' THEN r.value END ASC,
    CASE WHEN $5 = 'value' AND $6 = 'DESC' THEN r.value END DESC,
    r.created_at DESC
`

type ListAllRolesParams struct {
	ShowDeleted pgtype.Bool   `json:"show_deleted"`
	Search      pgtype.Text   `json:"search"`
	Values      []string      `json:"values"`
	Ids         []pgtype.UUID `json:"ids"`
	SortBy      interface{}   `json:"sort_by"`
	SortOrder   interface{}   `json:"sort_order"`
}

type ListAllRolesRow struct {
	ID            pgtype.UUID      `json:"id"`
	TitleRu       string           `json:"title_ru"`
	TitleEn       pgtype.Text      `json:"title_en"`
	TitleKk       pgtype.Text      `json:"title_kk"`
	DescriptionRu string           `json:"description_ru"`
	DescriptionKk pgtype.Text      `json:"description_kk"`
	DescriptionEn pgtype.Text      `json:"description_en"`
	Value         string           `json:"value"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	DeletedAt     pgtype.Timestamp `json:"deleted_at"`
	Permissions   interface{}      `json:"permissions"`
}

// ============================================================================
// LIST AND SEARCH OPERATIONS
// ============================================================================
func (q *Queries) ListAllRoles(ctx context.Context, arg ListAllRolesParams) ([]ListAllRolesRow, error) {
	rows, err := q.db.Query(ctx, listAllRoles,
		arg.ShowDeleted,
		arg.Search,
		arg.Values,
		arg.Ids,
		arg.SortBy,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllRolesRow{}
	for rows.Next() {
		var i ListAllRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.TitleRu,
			&i.TitleEn,
			&i.TitleKk,
			&i.DescriptionRu,
			&i.DescriptionKk,
			&i.DescriptionEn,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Permissions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginateAllRoles = `-- name: PaginateAllRoles :many
SELECT r.id, r.title_ru, r.title_en, r.title_kk, r.description_ru, r.description_kk, r.description_en, r.value, r.created_at, r.updated_at, r.deleted_at,
       COALESCE(
           json_agg(
               json_build_object(
                   'id', p.id,
                   'title_ru', p.title_ru,
                   'title_en', p.title_en,
                   'title_kk', p.title_kk,
                   'value', p.value,
                   'description_ru', p.description_ru,
                   'description_en', p.description_en,
                   'description_kk', p.description_kk,
                   'created_at', p.created_at,
                   'updated_at', p.updated_at,
                   'deleted_at', p.deleted_at
               )
           ) FILTER (WHERE p.id IS NOT NULL), '[]'
       ) as permissions
FROM roles r
LEFT JOIN role_permissions rp ON r.id = rp.role_id
LEFT JOIN permissions p ON rp.permission_id = p.id AND p.deleted_at IS NULL
WHERE
    -- show_deleted filter
    (CASE WHEN $1::boolean THEN TRUE ELSE r.deleted_at IS NULL END)
    -- search filter (title_ru, title_en, title_kk, description_ru, description_en, description_kk, value)
    AND (
        $2::text IS NULL OR
        r.title_ru ILIKE '%' || $2 || '%' OR
        r.title_en ILIKE '%' || $2 || '%' OR
        r.title_kk ILIKE '%' || $2 || '%' OR
        r.description_ru ILIKE '%' || $2 || '%' OR
        r.description_en ILIKE '%' || $2 || '%' OR
        r.description_kk ILIKE '%' || $2 || '%' OR
        r.value ILIKE '%' || $2 || '%'
    )
    -- values filter
    AND (
        $3::text[] IS NULL OR
        r.value = ANY($3::text[])
    )
    -- ids filter
    AND (
        $4::uuid[] IS NULL OR
        r.id = ANY($4::uuid[])
    )
GROUP BY r.id
ORDER BY
    CASE WHEN $5 = 'created_at' AND $6 = 'ASC' THEN r.created_at END ASC,
    CASE WHEN $5 = 'created_at' AND $6 = 'DESC' THEN r.created_at END DESC,
    CASE WHEN $5 = 'updated_at' AND $6 = 'ASC' THEN r.updated_at END ASC,
    CASE WHEN $5 = 'updated_at' AND $6 = 'DESC' THEN r.updated_at END DESC,
    CASE WHEN $5 = 'title_ru' AND $6 = 'ASC' THEN r.title_ru END ASC,
    CASE WHEN $5 = 'title_ru' AND $6 = 'DESC' THEN r.title_ru END DESC,
    CASE WHEN $5 = 'value' AND $6 = 'ASC' THEN r.value END ASC,
    CASE WHEN $5 = 'value' AND $6 = 'DESC' THEN r.value END DESC,
    r.created_at DESC
LIMIT $8 OFFSET $7
`

type PaginateAllRolesParams struct {
	ShowDeleted pgtype.Bool   `json:"show_deleted"`
	Search      pgtype.Text   `json:"search"`
	Values      []string      `json:"values"`
	Ids         []pgtype.UUID `json:"ids"`
	SortBy      interface{}   `json:"sort_by"`
	SortOrder   interface{}   `json:"sort_order"`
	Offset      int32         `json:"offset"`
	Limit       int32         `json:"limit"`
}

type PaginateAllRolesRow struct {
	ID            pgtype.UUID      `json:"id"`
	TitleRu       string           `json:"title_ru"`
	TitleEn       pgtype.Text      `json:"title_en"`
	TitleKk       pgtype.Text      `json:"title_kk"`
	DescriptionRu string           `json:"description_ru"`
	DescriptionKk pgtype.Text      `json:"description_kk"`
	DescriptionEn pgtype.Text      `json:"description_en"`
	Value         string           `json:"value"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	DeletedAt     pgtype.Timestamp `json:"deleted_at"`
	Permissions   interface{}      `json:"permissions"`
}

func (q *Queries) PaginateAllRoles(ctx context.Context, arg PaginateAllRolesParams) ([]PaginateAllRolesRow, error) {
	rows, err := q.db.Query(ctx, paginateAllRoles,
		arg.ShowDeleted,
		arg.Search,
		arg.Values,
		arg.Ids,
		arg.SortBy,
		arg.SortOrder,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaginateAllRolesRow{}
	for rows.Next() {
		var i PaginateAllRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.TitleRu,
			&i.TitleEn,
			&i.TitleKk,
			&i.DescriptionRu,
			&i.DescriptionKk,
			&i.DescriptionEn,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Permissions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRoleById = `-- name: UpdateRoleById :one
UPDATE roles
SET title_ru = $2,
    title_en = $3,
    title_kk = $4,
    description_ru = $5,
    description_en = $6,
    description_kk = $7,
    value = $8,
    updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title_ru, title_en, title_kk, description_ru, description_kk, description_en, value, created_at, updated_at, deleted_at
`

type UpdateRoleByIdParams struct {
	ID            pgtype.UUID `json:"id"`
	TitleRu       string      `json:"title_ru"`
	TitleEn       pgtype.Text `json:"title_en"`
	TitleKk       pgtype.Text `json:"title_kk"`
	DescriptionRu string      `json:"description_ru"`
	DescriptionEn pgtype.Text `json:"description_en"`
	DescriptionKk pgtype.Text `json:"description_kk"`
	Value         string      `json:"value"`
}

func (q *Queries) UpdateRoleById(ctx context.Context, arg UpdateRoleByIdParams) (Role, error) {
	row := q.db.QueryRow(ctx, updateRoleById,
		arg.ID,
		arg.TitleRu,
		arg.TitleEn,
		arg.TitleKk,
		arg.DescriptionRu,
		arg.DescriptionEn,
		arg.DescriptionKk,
		arg.Value,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.TitleRu,
		&i.TitleEn,
		&i.TitleKk,
		&i.DescriptionRu,
		&i.DescriptionKk,
		&i.DescriptionEn,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
