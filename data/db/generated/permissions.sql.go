// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: permissions.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreatePermissionsParams struct {
	ID            pgtype.UUID `json:"id"`
	TitleRu       string      `json:"title_ru"`
	TitleEn       pgtype.Text `json:"title_en"`
	TitleKk       pgtype.Text `json:"title_kk"`
	DescriptionRu string      `json:"description_ru"`
	DescriptionEn pgtype.Text `json:"description_en"`
	DescriptionKk pgtype.Text `json:"description_kk"`
	Value         string      `json:"value"`
}

const bulkDeletePermissionByIds = `-- name: BulkDeletePermissionByIds :many
UPDATE permissions
SET deleted_at = now(),
    updated_at = now()
WHERE id = ANY($1::uuid[]) AND deleted_at IS NULL
RETURNING id, title_ru, title_en, title_kk, description_ru, description_kk, description_en, value, created_at, updated_at, deleted_at
`

func (q *Queries) BulkDeletePermissionByIds(ctx context.Context, dollar_1 []pgtype.UUID) ([]Permission, error) {
	rows, err := q.db.Query(ctx, bulkDeletePermissionByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.TitleRu,
			&i.TitleEn,
			&i.TitleKk,
			&i.DescriptionRu,
			&i.DescriptionKk,
			&i.DescriptionEn,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bulkHardDeletePermissionByIds = `-- name: BulkHardDeletePermissionByIds :exec
DELETE FROM permissions
WHERE id = ANY($1::uuid[])
`

func (q *Queries) BulkHardDeletePermissionByIds(ctx context.Context, dollar_1 []pgtype.UUID) error {
	_, err := q.db.Exec(ctx, bulkHardDeletePermissionByIds, dollar_1)
	return err
}

const countAllPermissions = `-- name: CountAllPermissions :one
SELECT COUNT(DISTINCT p.id)
FROM permissions p
WHERE
    -- show_deleted filter
    (CASE WHEN $1::boolean THEN TRUE ELSE p.deleted_at IS NULL END)
    -- search filter
    AND (
        $2::text IS NULL OR
        p.title_ru ILIKE '%' || $2 || '%' OR
        p.title_en ILIKE '%' || $2 || '%' OR
        p.title_kk ILIKE '%' || $2 || '%' OR
        p.description_ru ILIKE '%' || $2 || '%' OR
        p.description_en ILIKE '%' || $2 || '%' OR
        p.description_kk ILIKE '%' || $2 || '%' OR
        p.value ILIKE '%' || $2 || '%'
    )
    -- values filter
    AND (
        $3::text[] IS NULL OR
        p.value = ANY($3::text[])
    )
    -- ids filter
    AND (
        $4::uuid[] IS NULL OR
        p.id = ANY($4::uuid[])
    )
`

type CountAllPermissionsParams struct {
	ShowDeleted pgtype.Bool   `json:"show_deleted"`
	Search      pgtype.Text   `json:"search"`
	Values      []string      `json:"values"`
	Ids         []pgtype.UUID `json:"ids"`
}

func (q *Queries) CountAllPermissions(ctx context.Context, arg CountAllPermissionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllPermissions,
		arg.ShowDeleted,
		arg.Search,
		arg.Values,
		arg.Ids,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOnePermission = `-- name: CreateOnePermission :one

INSERT INTO permissions (id, title_ru, title_en, title_kk, description_ru, description_en, description_kk, value)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, title_ru, title_en, title_kk, description_ru, description_kk, description_en, value, created_at, updated_at, deleted_at
`

type CreateOnePermissionParams struct {
	ID            pgtype.UUID `json:"id"`
	TitleRu       string      `json:"title_ru"`
	TitleEn       pgtype.Text `json:"title_en"`
	TitleKk       pgtype.Text `json:"title_kk"`
	DescriptionRu string      `json:"description_ru"`
	DescriptionEn pgtype.Text `json:"description_en"`
	DescriptionKk pgtype.Text `json:"description_kk"`
	Value         string      `json:"value"`
}

// ============================================================================
// BASIC CRUD OPERATIONS
// ============================================================================
func (q *Queries) CreateOnePermission(ctx context.Context, arg CreateOnePermissionParams) (Permission, error) {
	row := q.db.QueryRow(ctx, createOnePermission,
		arg.ID,
		arg.TitleRu,
		arg.TitleEn,
		arg.TitleKk,
		arg.DescriptionRu,
		arg.DescriptionEn,
		arg.DescriptionKk,
		arg.Value,
	)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.TitleRu,
		&i.TitleEn,
		&i.TitleKk,
		&i.DescriptionRu,
		&i.DescriptionKk,
		&i.DescriptionEn,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deletePermissionById = `-- name: DeletePermissionById :one
UPDATE permissions
SET deleted_at = now(),
    updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title_ru, title_en, title_kk, description_ru, description_kk, description_en, value, created_at, updated_at, deleted_at
`

func (q *Queries) DeletePermissionById(ctx context.Context, id pgtype.UUID) (Permission, error) {
	row := q.db.QueryRow(ctx, deletePermissionById, id)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.TitleRu,
		&i.TitleEn,
		&i.TitleKk,
		&i.DescriptionRu,
		&i.DescriptionKk,
		&i.DescriptionEn,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPermissionById = `-- name: GetPermissionById :one
SELECT p.id, p.title_ru, p.title_en, p.title_kk, p.description_ru, p.description_kk, p.description_en, p.value, p.created_at, p.updated_at, p.deleted_at,
       COALESCE(
           json_agg(
               json_build_object(
                   'id', r.id,
                   'title_ru', r.title_ru,
                   'title_en', r.title_en,
                   'title_kk', r.title_kk,
                   'value', r.value,
                   'description_ru', r.description_ru,
                   'description_en', r.description_en,
                   'description_kk', r.description_kk,
                   'created_at', r.created_at,
                   'updated_at', r.updated_at,
                   'deleted_at', r.deleted_at
               )
           ) FILTER (WHERE r.id IS NOT NULL), '[]'
       ) as roles
FROM permissions p
LEFT JOIN role_permissions rp ON p.id = rp.permission_id
LEFT JOIN roles r ON rp.role_id = r.id AND r.deleted_at IS NULL
WHERE p.id = $1 AND p.deleted_at IS NULL
GROUP BY p.id
`

type GetPermissionByIdRow struct {
	ID            pgtype.UUID      `json:"id"`
	TitleRu       string           `json:"title_ru"`
	TitleEn       pgtype.Text      `json:"title_en"`
	TitleKk       pgtype.Text      `json:"title_kk"`
	DescriptionRu string           `json:"description_ru"`
	DescriptionKk pgtype.Text      `json:"description_kk"`
	DescriptionEn pgtype.Text      `json:"description_en"`
	Value         string           `json:"value"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	DeletedAt     pgtype.Timestamp `json:"deleted_at"`
	Roles         interface{}      `json:"roles"`
}

func (q *Queries) GetPermissionById(ctx context.Context, id pgtype.UUID) (GetPermissionByIdRow, error) {
	row := q.db.QueryRow(ctx, getPermissionById, id)
	var i GetPermissionByIdRow
	err := row.Scan(
		&i.ID,
		&i.TitleRu,
		&i.TitleEn,
		&i.TitleKk,
		&i.DescriptionRu,
		&i.DescriptionKk,
		&i.DescriptionEn,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Roles,
	)
	return i, err
}

const getPermissionByValue = `-- name: GetPermissionByValue :one
SELECT p.id, p.title_ru, p.title_en, p.title_kk, p.description_ru, p.description_kk, p.description_en, p.value, p.created_at, p.updated_at, p.deleted_at,
       COALESCE(
           json_agg(
               json_build_object(
                   'id', r.id,
                   'title_ru', r.title_ru,
                   'title_en', r.title_en,
                   'title_kk', r.title_kk,
                   'value', r.value,
                   'description_ru', r.description_ru,
                   'description_en', r.description_en,
                   'description_kk', r.description_kk,
                   'created_at', r.created_at,
                   'updated_at', r.updated_at,
                   'deleted_at', r.deleted_at
               )
           ) FILTER (WHERE r.id IS NOT NULL), '[]'
       ) as roles
FROM permissions p
LEFT JOIN role_permissions rp ON p.id = rp.permission_id
LEFT JOIN roles r ON rp.role_id = r.id AND r.deleted_at IS NULL
WHERE p.value = $1 AND p.deleted_at IS NULL
GROUP BY p.id
`

type GetPermissionByValueRow struct {
	ID            pgtype.UUID      `json:"id"`
	TitleRu       string           `json:"title_ru"`
	TitleEn       pgtype.Text      `json:"title_en"`
	TitleKk       pgtype.Text      `json:"title_kk"`
	DescriptionRu string           `json:"description_ru"`
	DescriptionKk pgtype.Text      `json:"description_kk"`
	DescriptionEn pgtype.Text      `json:"description_en"`
	Value         string           `json:"value"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	DeletedAt     pgtype.Timestamp `json:"deleted_at"`
	Roles         interface{}      `json:"roles"`
}

func (q *Queries) GetPermissionByValue(ctx context.Context, value string) (GetPermissionByValueRow, error) {
	row := q.db.QueryRow(ctx, getPermissionByValue, value)
	var i GetPermissionByValueRow
	err := row.Scan(
		&i.ID,
		&i.TitleRu,
		&i.TitleEn,
		&i.TitleKk,
		&i.DescriptionRu,
		&i.DescriptionKk,
		&i.DescriptionEn,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Roles,
	)
	return i, err
}

const getPermissionWithRoles = `-- name: GetPermissionWithRoles :one

SELECT p.id, p.title_ru, p.title_en, p.title_kk, p.description_ru, p.description_kk, p.description_en, p.value, p.created_at, p.updated_at, p.deleted_at,
       COALESCE(
           json_agg(
               json_build_object(
                   'id', r.id,
                   'title_ru', r.title_ru,
                   'title_en', r.title_en,
                   'title_kk', r.title_kk,
                   'value', r.value,
                   'description_ru', r.description_ru,
                   'description_en', r.description_en,
                   'description_kk', r.description_kk
               )
           ) FILTER (WHERE r.id IS NOT NULL), '[]'
       ) as roles
FROM permissions p
LEFT JOIN role_permissions rp ON p.id = rp.permission_id
LEFT JOIN roles r ON rp.role_id = r.id AND r.deleted_at IS NULL
WHERE p.id = $1 AND p.deleted_at IS NULL
GROUP BY p.id
`

type GetPermissionWithRolesRow struct {
	ID            pgtype.UUID      `json:"id"`
	TitleRu       string           `json:"title_ru"`
	TitleEn       pgtype.Text      `json:"title_en"`
	TitleKk       pgtype.Text      `json:"title_kk"`
	DescriptionRu string           `json:"description_ru"`
	DescriptionKk pgtype.Text      `json:"description_kk"`
	DescriptionEn pgtype.Text      `json:"description_en"`
	Value         string           `json:"value"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	DeletedAt     pgtype.Timestamp `json:"deleted_at"`
	Roles         interface{}      `json:"roles"`
}

// ============================================================================
// LEGACY QUERIES (For backward compatibility)
// ============================================================================
func (q *Queries) GetPermissionWithRoles(ctx context.Context, id pgtype.UUID) (GetPermissionWithRolesRow, error) {
	row := q.db.QueryRow(ctx, getPermissionWithRoles, id)
	var i GetPermissionWithRolesRow
	err := row.Scan(
		&i.ID,
		&i.TitleRu,
		&i.TitleEn,
		&i.TitleKk,
		&i.DescriptionRu,
		&i.DescriptionKk,
		&i.DescriptionEn,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Roles,
	)
	return i, err
}

const hardDeletePermissionById = `-- name: HardDeletePermissionById :exec
DELETE FROM permissions
WHERE id = $1
`

func (q *Queries) HardDeletePermissionById(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, hardDeletePermissionById, id)
	return err
}

const listAllPermissions = `-- name: ListAllPermissions :many

SELECT p.id, p.title_ru, p.title_en, p.title_kk, p.description_ru, p.description_kk, p.description_en, p.value, p.created_at, p.updated_at, p.deleted_at,
       COALESCE(
           json_agg(
               json_build_object(
                   'id', r.id,
                   'title_ru', r.title_ru,
                   'title_en', r.title_en,
                   'title_kk', r.title_kk,
                   'value', r.value,
                   'description_ru', r.description_ru,
                   'description_en', r.description_en,
                   'description_kk', r.description_kk,
                   'created_at', r.created_at,
                   'updated_at', r.updated_at,
                   'deleted_at', r.deleted_at
               )
           ) FILTER (WHERE r.id IS NOT NULL), '[]'
       ) as roles
FROM permissions p
LEFT JOIN role_permissions rp ON p.id = rp.permission_id
LEFT JOIN roles r ON rp.role_id = r.id AND r.deleted_at IS NULL
WHERE
    -- show_deleted filter
    (CASE WHEN $1::boolean THEN TRUE ELSE p.deleted_at IS NULL END)
    -- search filter (title_ru, title_en, title_kk, description_ru, description_en, description_kk, value)
    AND (
        $2::text IS NULL OR
        p.title_ru ILIKE '%' || $2 || '%' OR
        p.title_en ILIKE '%' || $2 || '%' OR
        p.title_kk ILIKE '%' || $2 || '%' OR
        p.description_ru ILIKE '%' || $2 || '%' OR
        p.description_en ILIKE '%' || $2 || '%' OR
        p.description_kk ILIKE '%' || $2 || '%' OR
        p.value ILIKE '%' || $2 || '%'
    )
    -- values filter
    AND (
        $3::text[] IS NULL OR
        p.value = ANY($3::text[])
    )
    -- ids filter
    AND (
        $4::uuid[] IS NULL OR
        p.id = ANY($4::uuid[])
    )
GROUP BY p.id
ORDER BY
    CASE WHEN $5 = 'created_at' AND $6 = 'ASC' THEN p.created_at END ASC,
    CASE WHEN $5 = 'created_at' AND $6 = 'DESC' THEN p.created_at END DESC,
    CASE WHEN $5 = 'updated_at' AND $6 = 'ASC' THEN p.updated_at END ASC,
    CASE WHEN $5 = 'updated_at' AND $6 = 'DESC' THEN p.updated_at END DESC,
    CASE WHEN $5 = 'title_ru' AND $6 = 'ASC' THEN p.title_ru END ASC,
    CASE WHEN $5 = 'title_ru' AND $6 = 'DESC' THEN p.title_ru END DESC,
    CASE WHEN $5 = 'value' AND $6 = 'ASC' THEN p.value END ASC,
    CASE WHEN $5 = 'value' AND $6 = 'DESC' THEN p.value END DESC,
    p.created_at DESC
`

type ListAllPermissionsParams struct {
	ShowDeleted pgtype.Bool   `json:"show_deleted"`
	Search      pgtype.Text   `json:"search"`
	Values      []string      `json:"values"`
	Ids         []pgtype.UUID `json:"ids"`
	SortBy      interface{}   `json:"sort_by"`
	SortOrder   interface{}   `json:"sort_order"`
}

type ListAllPermissionsRow struct {
	ID            pgtype.UUID      `json:"id"`
	TitleRu       string           `json:"title_ru"`
	TitleEn       pgtype.Text      `json:"title_en"`
	TitleKk       pgtype.Text      `json:"title_kk"`
	DescriptionRu string           `json:"description_ru"`
	DescriptionKk pgtype.Text      `json:"description_kk"`
	DescriptionEn pgtype.Text      `json:"description_en"`
	Value         string           `json:"value"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	DeletedAt     pgtype.Timestamp `json:"deleted_at"`
	Roles         interface{}      `json:"roles"`
}

// ============================================================================
// LIST AND SEARCH OPERATIONS
// ============================================================================
func (q *Queries) ListAllPermissions(ctx context.Context, arg ListAllPermissionsParams) ([]ListAllPermissionsRow, error) {
	rows, err := q.db.Query(ctx, listAllPermissions,
		arg.ShowDeleted,
		arg.Search,
		arg.Values,
		arg.Ids,
		arg.SortBy,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllPermissionsRow{}
	for rows.Next() {
		var i ListAllPermissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.TitleRu,
			&i.TitleEn,
			&i.TitleKk,
			&i.DescriptionRu,
			&i.DescriptionKk,
			&i.DescriptionEn,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginateAllPermissions = `-- name: PaginateAllPermissions :many
SELECT p.id, p.title_ru, p.title_en, p.title_kk, p.description_ru, p.description_kk, p.description_en, p.value, p.created_at, p.updated_at, p.deleted_at,
       COALESCE(
           json_agg(
               json_build_object(
                   'id', r.id,
                   'title_ru', r.title_ru,
                   'title_en', r.title_en,
                   'title_kk', r.title_kk,
                   'value', r.value,
                   'description_ru', r.description_ru,
                   'description_en', r.description_en,
                   'description_kk', r.description_kk,
                   'created_at', r.created_at,
                   'updated_at', r.updated_at,
                   'deleted_at', r.deleted_at
               )
           ) FILTER (WHERE r.id IS NOT NULL), '[]'
       ) as roles
FROM permissions p
LEFT JOIN role_permissions rp ON p.id = rp.permission_id
LEFT JOIN roles r ON rp.role_id = r.id AND r.deleted_at IS NULL
WHERE
    -- show_deleted filter
    (CASE WHEN $1::boolean THEN TRUE ELSE p.deleted_at IS NULL END)
    -- search filter (title_ru, title_en, title_kk, description_ru, description_en, description_kk, value)
    AND (
        $2::text IS NULL OR
        p.title_ru ILIKE '%' || $2 || '%' OR
        p.title_en ILIKE '%' || $2 || '%' OR
        p.title_kk ILIKE '%' || $2 || '%' OR
        p.description_ru ILIKE '%' || $2 || '%' OR
        p.description_en ILIKE '%' || $2 || '%' OR
        p.description_kk ILIKE '%' || $2 || '%' OR
        p.value ILIKE '%' || $2 || '%'
    )
    -- values filter
    AND (
        $3::text[] IS NULL OR
        p.value = ANY($3::text[])
    )
    -- ids filter
    AND (
        $4::uuid[] IS NULL OR
        p.id = ANY($4::uuid[])
    )
GROUP BY p.id
ORDER BY
    CASE WHEN $5 = 'created_at' AND $6 = 'ASC' THEN p.created_at END ASC,
    CASE WHEN $5 = 'created_at' AND $6 = 'DESC' THEN p.created_at END DESC,
    CASE WHEN $5 = 'updated_at' AND $6 = 'ASC' THEN p.updated_at END ASC,
    CASE WHEN $5 = 'updated_at' AND $6 = 'DESC' THEN p.updated_at END DESC,
    CASE WHEN $5 = 'title_ru' AND $6 = 'ASC' THEN p.title_ru END ASC,
    CASE WHEN $5 = 'title_ru' AND $6 = 'DESC' THEN p.title_ru END DESC,
    CASE WHEN $5 = 'value' AND $6 = 'ASC' THEN p.value END ASC,
    CASE WHEN $5 = 'value' AND $6 = 'DESC' THEN p.value END DESC,
    p.created_at DESC
LIMIT $8 OFFSET $7
`

type PaginateAllPermissionsParams struct {
	ShowDeleted pgtype.Bool   `json:"show_deleted"`
	Search      pgtype.Text   `json:"search"`
	Values      []string      `json:"values"`
	Ids         []pgtype.UUID `json:"ids"`
	SortBy      interface{}   `json:"sort_by"`
	SortOrder   interface{}   `json:"sort_order"`
	Offset      int32         `json:"offset"`
	Limit       int32         `json:"limit"`
}

type PaginateAllPermissionsRow struct {
	ID            pgtype.UUID      `json:"id"`
	TitleRu       string           `json:"title_ru"`
	TitleEn       pgtype.Text      `json:"title_en"`
	TitleKk       pgtype.Text      `json:"title_kk"`
	DescriptionRu string           `json:"description_ru"`
	DescriptionKk pgtype.Text      `json:"description_kk"`
	DescriptionEn pgtype.Text      `json:"description_en"`
	Value         string           `json:"value"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	DeletedAt     pgtype.Timestamp `json:"deleted_at"`
	Roles         interface{}      `json:"roles"`
}

func (q *Queries) PaginateAllPermissions(ctx context.Context, arg PaginateAllPermissionsParams) ([]PaginateAllPermissionsRow, error) {
	rows, err := q.db.Query(ctx, paginateAllPermissions,
		arg.ShowDeleted,
		arg.Search,
		arg.Values,
		arg.Ids,
		arg.SortBy,
		arg.SortOrder,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaginateAllPermissionsRow{}
	for rows.Next() {
		var i PaginateAllPermissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.TitleRu,
			&i.TitleEn,
			&i.TitleKk,
			&i.DescriptionRu,
			&i.DescriptionKk,
			&i.DescriptionEn,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePermissionById = `-- name: UpdatePermissionById :one
UPDATE permissions
SET title_ru = $2,
    title_en = $3,
    title_kk = $4,
    description_ru = $5,
    description_en = $6,
    description_kk = $7,
    value = $8,
    updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title_ru, title_en, title_kk, description_ru, description_kk, description_en, value, created_at, updated_at, deleted_at
`

type UpdatePermissionByIdParams struct {
	ID            pgtype.UUID `json:"id"`
	TitleRu       string      `json:"title_ru"`
	TitleEn       pgtype.Text `json:"title_en"`
	TitleKk       pgtype.Text `json:"title_kk"`
	DescriptionRu string      `json:"description_ru"`
	DescriptionEn pgtype.Text `json:"description_en"`
	DescriptionKk pgtype.Text `json:"description_kk"`
	Value         string      `json:"value"`
}

func (q *Queries) UpdatePermissionById(ctx context.Context, arg UpdatePermissionByIdParams) (Permission, error) {
	row := q.db.QueryRow(ctx, updatePermissionById,
		arg.ID,
		arg.TitleRu,
		arg.TitleEn,
		arg.TitleKk,
		arg.DescriptionRu,
		arg.DescriptionEn,
		arg.DescriptionKk,
		arg.Value,
	)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.TitleRu,
		&i.TitleEn,
		&i.TitleKk,
		&i.DescriptionRu,
		&i.DescriptionKk,
		&i.DescriptionEn,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
