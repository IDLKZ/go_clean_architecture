// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: role_permissions.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignPermissionToRole = `-- name: AssignPermissionToRole :one

INSERT INTO role_permissions (id, role_id, permission_id)
VALUES ($1, $2, $3)
ON CONFLICT (role_id, permission_id) DO NOTHING
RETURNING id, role_id, permission_id, created_at
`

type AssignPermissionToRoleParams struct {
	ID           pgtype.UUID `json:"id"`
	RoleID       pgtype.UUID `json:"role_id"`
	PermissionID pgtype.UUID `json:"permission_id"`
}

// ============================================================================
// LEGACY QUERIES (For backward compatibility)
// ============================================================================
func (q *Queries) AssignPermissionToRole(ctx context.Context, arg AssignPermissionToRoleParams) (RolePermission, error) {
	row := q.db.QueryRow(ctx, assignPermissionToRole, arg.ID, arg.RoleID, arg.PermissionID)
	var i RolePermission
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.PermissionID,
		&i.CreatedAt,
	)
	return i, err
}

const bulkAssignPermissionsToRole = `-- name: BulkAssignPermissionsToRole :many
INSERT INTO role_permissions (id, role_id, permission_id)
SELECT gen_random_uuid(), $1, unnest($2::uuid[])
ON CONFLICT (role_id, permission_id) DO NOTHING
RETURNING id, role_id, permission_id, created_at
`

type BulkAssignPermissionsToRoleParams struct {
	RoleID  pgtype.UUID   `json:"role_id"`
	Column2 []pgtype.UUID `json:"column_2"`
}

func (q *Queries) BulkAssignPermissionsToRole(ctx context.Context, arg BulkAssignPermissionsToRoleParams) ([]RolePermission, error) {
	rows, err := q.db.Query(ctx, bulkAssignPermissionsToRole, arg.RoleID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RolePermission{}
	for rows.Next() {
		var i RolePermission
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.PermissionID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bulkAssignRolesToPermission = `-- name: BulkAssignRolesToPermission :many
INSERT INTO role_permissions (id, role_id, permission_id)
SELECT gen_random_uuid(), unnest($1::uuid[]), $2
ON CONFLICT (role_id, permission_id) DO NOTHING
RETURNING id, role_id, permission_id, created_at
`

type BulkAssignRolesToPermissionParams struct {
	Column1      []pgtype.UUID `json:"column_1"`
	PermissionID pgtype.UUID   `json:"permission_id"`
}

func (q *Queries) BulkAssignRolesToPermission(ctx context.Context, arg BulkAssignRolesToPermissionParams) ([]RolePermission, error) {
	rows, err := q.db.Query(ctx, bulkAssignRolesToPermission, arg.Column1, arg.PermissionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RolePermission{}
	for rows.Next() {
		var i RolePermission
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.PermissionID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type BulkCreateRolePermissionsParams struct {
	ID           pgtype.UUID `json:"id"`
	RoleID       pgtype.UUID `json:"role_id"`
	PermissionID pgtype.UUID `json:"permission_id"`
}

const bulkDeleteRolePermissionByIds = `-- name: BulkDeleteRolePermissionByIds :exec
DELETE FROM role_permissions
WHERE id = ANY($1::uuid[])
`

func (q *Queries) BulkDeleteRolePermissionByIds(ctx context.Context, dollar_1 []pgtype.UUID) error {
	_, err := q.db.Exec(ctx, bulkDeleteRolePermissionByIds, dollar_1)
	return err
}

const bulkRemovePermissionsFromRole = `-- name: BulkRemovePermissionsFromRole :many
DELETE FROM role_permissions
WHERE role_id = $1 AND permission_id = ANY($2::uuid[])
RETURNING id, role_id, permission_id, created_at
`

type BulkRemovePermissionsFromRoleParams struct {
	RoleID  pgtype.UUID   `json:"role_id"`
	Column2 []pgtype.UUID `json:"column_2"`
}

func (q *Queries) BulkRemovePermissionsFromRole(ctx context.Context, arg BulkRemovePermissionsFromRoleParams) ([]RolePermission, error) {
	rows, err := q.db.Query(ctx, bulkRemovePermissionsFromRole, arg.RoleID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RolePermission{}
	for rows.Next() {
		var i RolePermission
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.PermissionID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bulkRemoveRolesFromPermission = `-- name: BulkRemoveRolesFromPermission :many
DELETE FROM role_permissions
WHERE permission_id = $1 AND role_id = ANY($2::uuid[])
RETURNING id, role_id, permission_id, created_at
`

type BulkRemoveRolesFromPermissionParams struct {
	PermissionID pgtype.UUID   `json:"permission_id"`
	Column2      []pgtype.UUID `json:"column_2"`
}

func (q *Queries) BulkRemoveRolesFromPermission(ctx context.Context, arg BulkRemoveRolesFromPermissionParams) ([]RolePermission, error) {
	rows, err := q.db.Query(ctx, bulkRemoveRolesFromPermission, arg.PermissionID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RolePermission{}
	for rows.Next() {
		var i RolePermission
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.PermissionID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkRoleHasPermission = `-- name: CheckRoleHasPermission :one

SELECT EXISTS(
    SELECT 1
    FROM role_permissions rp
    INNER JOIN roles r ON rp.role_id = r.id
    INNER JOIN permissions p ON rp.permission_id = p.id
    WHERE rp.role_id = $1
      AND rp.permission_id = $2
      AND r.deleted_at IS NULL
      AND p.deleted_at IS NULL
) as exists
`

type CheckRoleHasPermissionParams struct {
	RoleID       pgtype.UUID `json:"role_id"`
	PermissionID pgtype.UUID `json:"permission_id"`
}

// ============================================================================
// UTILITY OPERATIONS
// ============================================================================
func (q *Queries) CheckRoleHasPermission(ctx context.Context, arg CheckRoleHasPermissionParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkRoleHasPermission, arg.RoleID, arg.PermissionID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkRoleHasPermissionByValue = `-- name: CheckRoleHasPermissionByValue :one
SELECT EXISTS(
    SELECT 1
    FROM role_permissions rp
    INNER JOIN roles r ON rp.role_id = r.id
    INNER JOIN permissions p ON rp.permission_id = p.id
    WHERE r.value = $1
      AND p.value = $2
      AND r.deleted_at IS NULL
      AND p.deleted_at IS NULL
) as exists
`

type CheckRoleHasPermissionByValueParams struct {
	Value   string `json:"value"`
	Value_2 string `json:"value_2"`
}

func (q *Queries) CheckRoleHasPermissionByValue(ctx context.Context, arg CheckRoleHasPermissionByValueParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkRoleHasPermissionByValue, arg.Value, arg.Value_2)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countAllRolePermissions = `-- name: CountAllRolePermissions :one
SELECT COUNT(*)
FROM role_permissions rp
INNER JOIN roles r ON rp.role_id = r.id
INNER JOIN permissions p ON rp.permission_id = p.id
WHERE
    r.deleted_at IS NULL
    AND p.deleted_at IS NULL
    -- role_ids filter
    AND (
        $1::uuid[] IS NULL OR
        rp.role_id = ANY($1::uuid[])
    )
    -- permission_ids filter
    AND (
        $2::uuid[] IS NULL OR
        rp.permission_id = ANY($2::uuid[])
    )
    -- role_values filter
    AND (
        $3::text[] IS NULL OR
        r.value = ANY($3::text[])
    )
    -- permission_values filter
    AND (
        $4::text[] IS NULL OR
        p.value = ANY($4::text[])
    )
`

type CountAllRolePermissionsParams struct {
	RoleIds          []pgtype.UUID `json:"role_ids"`
	PermissionIds    []pgtype.UUID `json:"permission_ids"`
	RoleValues       []string      `json:"role_values"`
	PermissionValues []string      `json:"permission_values"`
}

func (q *Queries) CountAllRolePermissions(ctx context.Context, arg CountAllRolePermissionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllRolePermissions,
		arg.RoleIds,
		arg.PermissionIds,
		arg.RoleValues,
		arg.PermissionValues,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPermissionRoles = `-- name: CountPermissionRoles :one
SELECT COUNT(*)
FROM role_permissions rp
INNER JOIN roles r ON rp.role_id = r.id
WHERE rp.permission_id = $1
  AND r.deleted_at IS NULL
`

func (q *Queries) CountPermissionRoles(ctx context.Context, permissionID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPermissionRoles, permissionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRolePermissions = `-- name: CountRolePermissions :one
SELECT COUNT(*)
FROM role_permissions rp
INNER JOIN permissions p ON rp.permission_id = p.id
WHERE rp.role_id = $1
  AND p.deleted_at IS NULL
`

func (q *Queries) CountRolePermissions(ctx context.Context, roleID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countRolePermissions, roleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOneRolePermission = `-- name: CreateOneRolePermission :one

INSERT INTO role_permissions (id, role_id, permission_id)
VALUES ($1, $2, $3)
ON CONFLICT (role_id, permission_id) DO NOTHING
RETURNING id, role_id, permission_id, created_at
`

type CreateOneRolePermissionParams struct {
	ID           pgtype.UUID `json:"id"`
	RoleID       pgtype.UUID `json:"role_id"`
	PermissionID pgtype.UUID `json:"permission_id"`
}

// ============================================================================
// BASIC CRUD OPERATIONS
// ============================================================================
func (q *Queries) CreateOneRolePermission(ctx context.Context, arg CreateOneRolePermissionParams) (RolePermission, error) {
	row := q.db.QueryRow(ctx, createOneRolePermission, arg.ID, arg.RoleID, arg.PermissionID)
	var i RolePermission
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.PermissionID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRolePermissionById = `-- name: DeleteRolePermissionById :one
DELETE FROM role_permissions
WHERE id = $1
RETURNING id, role_id, permission_id, created_at
`

func (q *Queries) DeleteRolePermissionById(ctx context.Context, id pgtype.UUID) (RolePermission, error) {
	row := q.db.QueryRow(ctx, deleteRolePermissionById, id)
	var i RolePermission
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.PermissionID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRolePermissionByRoleAndPermission = `-- name: DeleteRolePermissionByRoleAndPermission :one
DELETE FROM role_permissions
WHERE role_id = $1 AND permission_id = $2
RETURNING id, role_id, permission_id, created_at
`

type DeleteRolePermissionByRoleAndPermissionParams struct {
	RoleID       pgtype.UUID `json:"role_id"`
	PermissionID pgtype.UUID `json:"permission_id"`
}

func (q *Queries) DeleteRolePermissionByRoleAndPermission(ctx context.Context, arg DeleteRolePermissionByRoleAndPermissionParams) (RolePermission, error) {
	row := q.db.QueryRow(ctx, deleteRolePermissionByRoleAndPermission, arg.RoleID, arg.PermissionID)
	var i RolePermission
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.PermissionID,
		&i.CreatedAt,
	)
	return i, err
}

const getPermissionRoles = `-- name: GetPermissionRoles :many
SELECT r.id, r.title_ru, r.title_en, r.title_kk, r.description_ru, r.description_kk, r.description_en, r.value, r.created_at, r.updated_at, r.deleted_at
FROM roles r
INNER JOIN role_permissions rp ON r.id = rp.role_id
WHERE rp.permission_id = $1 AND r.deleted_at IS NULL
ORDER BY r.created_at DESC
`

func (q *Queries) GetPermissionRoles(ctx context.Context, permissionID pgtype.UUID) ([]Role, error) {
	rows, err := q.db.Query(ctx, getPermissionRoles, permissionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.TitleRu,
			&i.TitleEn,
			&i.TitleKk,
			&i.DescriptionRu,
			&i.DescriptionKk,
			&i.DescriptionEn,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolePermissionByID = `-- name: GetRolePermissionByID :one
SELECT id, role_id, permission_id, created_at FROM role_permissions
WHERE id = $1
`

func (q *Queries) GetRolePermissionByID(ctx context.Context, id pgtype.UUID) (RolePermission, error) {
	row := q.db.QueryRow(ctx, getRolePermissionByID, id)
	var i RolePermission
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.PermissionID,
		&i.CreatedAt,
	)
	return i, err
}

const getRolePermissionById = `-- name: GetRolePermissionById :one
SELECT rp.id, rp.role_id, rp.permission_id, rp.created_at,
       json_build_object(
           'id', r.id,
           'title_ru', r.title_ru,
           'title_en', r.title_en,
           'title_kk', r.title_kk,
           'value', r.value,
           'description_ru', r.description_ru,
           'description_en', r.description_en,
           'description_kk', r.description_kk,
           'created_at', r.created_at,
           'updated_at', r.updated_at,
           'deleted_at', r.deleted_at
       ) as role_use_case,
       json_build_object(
           'id', p.id,
           'title_ru', p.title_ru,
           'title_en', p.title_en,
           'title_kk', p.title_kk,
           'value', p.value,
           'description_ru', p.description_ru,
           'description_en', p.description_en,
           'description_kk', p.description_kk,
           'created_at', p.created_at,
           'updated_at', p.updated_at,
           'deleted_at', p.deleted_at
       ) as permission
FROM role_permissions rp
INNER JOIN roles r ON rp.role_id = r.id
INNER JOIN permissions p ON rp.permission_id = p.id
WHERE rp.id = $1
  AND r.deleted_at IS NULL
  AND p.deleted_at IS NULL
`

type GetRolePermissionByIdRow struct {
	ID           pgtype.UUID      `json:"id"`
	RoleID       pgtype.UUID      `json:"role_id"`
	PermissionID pgtype.UUID      `json:"permission_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	Role         []byte           `json:"role_use_case"`
	Permission   []byte           `json:"permission"`
}

func (q *Queries) GetRolePermissionById(ctx context.Context, id pgtype.UUID) (GetRolePermissionByIdRow, error) {
	row := q.db.QueryRow(ctx, getRolePermissionById, id)
	var i GetRolePermissionByIdRow
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.PermissionID,
		&i.CreatedAt,
		&i.Role,
		&i.Permission,
	)
	return i, err
}

const getRolePermissionByRoleAndPermission = `-- name: GetRolePermissionByRoleAndPermission :one
SELECT rp.id, rp.role_id, rp.permission_id, rp.created_at,
       json_build_object(
           'id', r.id,
           'title_ru', r.title_ru,
           'title_en', r.title_en,
           'title_kk', r.title_kk,
           'value', r.value,
           'description_ru', r.description_ru,
           'description_en', r.description_en,
           'description_kk', r.description_kk,
           'created_at', r.created_at,
           'updated_at', r.updated_at,
           'deleted_at', r.deleted_at
       ) as role_use_case,
       json_build_object(
           'id', p.id,
           'title_ru', p.title_ru,
           'title_en', p.title_en,
           'title_kk', p.title_kk,
           'value', p.value,
           'description_ru', p.description_ru,
           'description_en', p.description_en,
           'description_kk', p.description_kk,
           'created_at', p.created_at,
           'updated_at', p.updated_at,
           'deleted_at', p.deleted_at
       ) as permission
FROM role_permissions rp
INNER JOIN roles r ON rp.role_id = r.id
INNER JOIN permissions p ON rp.permission_id = p.id
WHERE rp.role_id = $1
  AND rp.permission_id = $2
  AND r.deleted_at IS NULL
  AND p.deleted_at IS NULL
`

type GetRolePermissionByRoleAndPermissionParams struct {
	RoleID       pgtype.UUID `json:"role_id"`
	PermissionID pgtype.UUID `json:"permission_id"`
}

type GetRolePermissionByRoleAndPermissionRow struct {
	ID           pgtype.UUID      `json:"id"`
	RoleID       pgtype.UUID      `json:"role_id"`
	PermissionID pgtype.UUID      `json:"permission_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	Role         []byte           `json:"role_use_case"`
	Permission   []byte           `json:"permission"`
}

func (q *Queries) GetRolePermissionByRoleAndPermission(ctx context.Context, arg GetRolePermissionByRoleAndPermissionParams) (GetRolePermissionByRoleAndPermissionRow, error) {
	row := q.db.QueryRow(ctx, getRolePermissionByRoleAndPermission, arg.RoleID, arg.PermissionID)
	var i GetRolePermissionByRoleAndPermissionRow
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.PermissionID,
		&i.CreatedAt,
		&i.Role,
		&i.Permission,
	)
	return i, err
}

const getRolePermissions = `-- name: GetRolePermissions :many
SELECT p.id, p.title_ru, p.title_en, p.title_kk, p.description_ru, p.description_kk, p.description_en, p.value, p.created_at, p.updated_at, p.deleted_at
FROM permissions p
INNER JOIN role_permissions rp ON p.id = rp.permission_id
WHERE rp.role_id = $1 AND p.deleted_at IS NULL
ORDER BY p.created_at DESC
`

func (q *Queries) GetRolePermissions(ctx context.Context, roleID pgtype.UUID) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getRolePermissions, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.TitleRu,
			&i.TitleEn,
			&i.TitleKk,
			&i.DescriptionRu,
			&i.DescriptionKk,
			&i.DescriptionEn,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllRolePermissions = `-- name: ListAllRolePermissions :many

SELECT rp.id, rp.role_id, rp.permission_id, rp.created_at,
       json_build_object(
           'id', r.id,
           'title_ru', r.title_ru,
           'title_en', r.title_en,
           'title_kk', r.title_kk,
           'value', r.value,
           'description_ru', r.description_ru,
           'description_en', r.description_en,
           'description_kk', r.description_kk,
           'created_at', r.created_at,
           'updated_at', r.updated_at,
           'deleted_at', r.deleted_at
       ) as role_use_case,
       json_build_object(
           'id', p.id,
           'title_ru', p.title_ru,
           'title_en', p.title_en,
           'title_kk', p.title_kk,
           'value', p.value,
           'description_ru', p.description_ru,
           'description_en', p.description_en,
           'description_kk', p.description_kk,
           'created_at', p.created_at,
           'updated_at', p.updated_at,
           'deleted_at', p.deleted_at
       ) as permission
FROM role_permissions rp
INNER JOIN roles r ON rp.role_id = r.id
INNER JOIN permissions p ON rp.permission_id = p.id
WHERE
    r.deleted_at IS NULL
    AND p.deleted_at IS NULL
    -- role_ids filter
    AND (
        $1::uuid[] IS NULL OR
        rp.role_id = ANY($1::uuid[])
    )
    -- permission_ids filter
    AND (
        $2::uuid[] IS NULL OR
        rp.permission_id = ANY($2::uuid[])
    )
    -- role_values filter
    AND (
        $3::text[] IS NULL OR
        r.value = ANY($3::text[])
    )
    -- permission_values filter
    AND (
        $4::text[] IS NULL OR
        p.value = ANY($4::text[])
    )
ORDER BY
    CASE WHEN $5 = 'created_at' AND $6 = 'ASC' THEN rp.created_at END ASC,
    CASE WHEN $5 = 'created_at' AND $6 = 'DESC' THEN rp.created_at END DESC,
    CASE WHEN $5 = 'role_value' AND $6 = 'ASC' THEN r.value END ASC,
    CASE WHEN $5 = 'role_value' AND $6 = 'DESC' THEN r.value END DESC,
    CASE WHEN $5 = 'permission_value' AND $6 = 'ASC' THEN p.value END ASC,
    CASE WHEN $5 = 'permission_value' AND $6 = 'DESC' THEN p.value END DESC,
    rp.created_at DESC
`

type ListAllRolePermissionsParams struct {
	RoleIds          []pgtype.UUID `json:"role_ids"`
	PermissionIds    []pgtype.UUID `json:"permission_ids"`
	RoleValues       []string      `json:"role_values"`
	PermissionValues []string      `json:"permission_values"`
	SortBy           interface{}   `json:"sort_by"`
	SortOrder        interface{}   `json:"sort_order"`
}

type ListAllRolePermissionsRow struct {
	ID           pgtype.UUID      `json:"id"`
	RoleID       pgtype.UUID      `json:"role_id"`
	PermissionID pgtype.UUID      `json:"permission_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	Role         []byte           `json:"role_use_case"`
	Permission   []byte           `json:"permission"`
}

// ============================================================================
// LIST AND SEARCH OPERATIONS
// ============================================================================
func (q *Queries) ListAllRolePermissions(ctx context.Context, arg ListAllRolePermissionsParams) ([]ListAllRolePermissionsRow, error) {
	rows, err := q.db.Query(ctx, listAllRolePermissions,
		arg.RoleIds,
		arg.PermissionIds,
		arg.RoleValues,
		arg.PermissionValues,
		arg.SortBy,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllRolePermissionsRow{}
	for rows.Next() {
		var i ListAllRolePermissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.PermissionID,
			&i.CreatedAt,
			&i.Role,
			&i.Permission,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginateAllRolePermissions = `-- name: PaginateAllRolePermissions :many
SELECT rp.id, rp.role_id, rp.permission_id, rp.created_at,
       json_build_object(
           'id', r.id,
           'title_ru', r.title_ru,
           'title_en', r.title_en,
           'title_kk', r.title_kk,
           'value', r.value,
           'description_ru', r.description_ru,
           'description_en', r.description_en,
           'description_kk', r.description_kk,
           'created_at', r.created_at,
           'updated_at', r.updated_at,
           'deleted_at', r.deleted_at
       ) as role_use_case,
       json_build_object(
           'id', p.id,
           'title_ru', p.title_ru,
           'title_en', p.title_en,
           'title_kk', p.title_kk,
           'value', p.value,
           'description_ru', p.description_ru,
           'description_en', p.description_en,
           'description_kk', p.description_kk,
           'created_at', p.created_at,
           'updated_at', p.updated_at,
           'deleted_at', p.deleted_at
       ) as permission
FROM role_permissions rp
INNER JOIN roles r ON rp.role_id = r.id
INNER JOIN permissions p ON rp.permission_id = p.id
WHERE
    r.deleted_at IS NULL
    AND p.deleted_at IS NULL
    -- role_ids filter
    AND (
        $1::uuid[] IS NULL OR
        rp.role_id = ANY($1::uuid[])
    )
    -- permission_ids filter
    AND (
        $2::uuid[] IS NULL OR
        rp.permission_id = ANY($2::uuid[])
    )
    -- role_values filter
    AND (
        $3::text[] IS NULL OR
        r.value = ANY($3::text[])
    )
    -- permission_values filter
    AND (
        $4::text[] IS NULL OR
        p.value = ANY($4::text[])
    )
ORDER BY
    CASE WHEN $5 = 'created_at' AND $6 = 'ASC' THEN rp.created_at END ASC,
    CASE WHEN $5 = 'created_at' AND $6 = 'DESC' THEN rp.created_at END DESC,
    CASE WHEN $5 = 'role_value' AND $6 = 'ASC' THEN r.value END ASC,
    CASE WHEN $5 = 'role_value' AND $6 = 'DESC' THEN r.value END DESC,
    CASE WHEN $5 = 'permission_value' AND $6 = 'ASC' THEN p.value END ASC,
    CASE WHEN $5 = 'permission_value' AND $6 = 'DESC' THEN p.value END DESC,
    rp.created_at DESC
LIMIT $8 OFFSET $7
`

type PaginateAllRolePermissionsParams struct {
	RoleIds          []pgtype.UUID `json:"role_ids"`
	PermissionIds    []pgtype.UUID `json:"permission_ids"`
	RoleValues       []string      `json:"role_values"`
	PermissionValues []string      `json:"permission_values"`
	SortBy           interface{}   `json:"sort_by"`
	SortOrder        interface{}   `json:"sort_order"`
	Offset           int32         `json:"offset"`
	Limit            int32         `json:"limit"`
}

type PaginateAllRolePermissionsRow struct {
	ID           pgtype.UUID      `json:"id"`
	RoleID       pgtype.UUID      `json:"role_id"`
	PermissionID pgtype.UUID      `json:"permission_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	Role         []byte           `json:"role_use_case"`
	Permission   []byte           `json:"permission"`
}

func (q *Queries) PaginateAllRolePermissions(ctx context.Context, arg PaginateAllRolePermissionsParams) ([]PaginateAllRolePermissionsRow, error) {
	rows, err := q.db.Query(ctx, paginateAllRolePermissions,
		arg.RoleIds,
		arg.PermissionIds,
		arg.RoleValues,
		arg.PermissionValues,
		arg.SortBy,
		arg.SortOrder,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaginateAllRolePermissionsRow{}
	for rows.Next() {
		var i PaginateAllRolePermissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.PermissionID,
			&i.CreatedAt,
			&i.Role,
			&i.Permission,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllPermissionsFromRole = `-- name: RemoveAllPermissionsFromRole :many
DELETE FROM role_permissions
WHERE role_id = $1
RETURNING id, role_id, permission_id, created_at
`

func (q *Queries) RemoveAllPermissionsFromRole(ctx context.Context, roleID pgtype.UUID) ([]RolePermission, error) {
	rows, err := q.db.Query(ctx, removeAllPermissionsFromRole, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RolePermission{}
	for rows.Next() {
		var i RolePermission
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.PermissionID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllRolesFromPermission = `-- name: RemoveAllRolesFromPermission :many
DELETE FROM role_permissions
WHERE permission_id = $1
RETURNING id, role_id, permission_id, created_at
`

func (q *Queries) RemoveAllRolesFromPermission(ctx context.Context, permissionID pgtype.UUID) ([]RolePermission, error) {
	rows, err := q.db.Query(ctx, removeAllRolesFromPermission, permissionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RolePermission{}
	for rows.Next() {
		var i RolePermission
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.PermissionID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePermissionFromRole = `-- name: RemovePermissionFromRole :exec
DELETE FROM role_permissions
WHERE role_id = $1 AND permission_id = $2
`

type RemovePermissionFromRoleParams struct {
	RoleID       pgtype.UUID `json:"role_id"`
	PermissionID pgtype.UUID `json:"permission_id"`
}

func (q *Queries) RemovePermissionFromRole(ctx context.Context, arg RemovePermissionFromRoleParams) error {
	_, err := q.db.Exec(ctx, removePermissionFromRole, arg.RoleID, arg.PermissionID)
	return err
}
