// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: batch.go

package generated

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const bulkUpdatePermissions = `-- name: BulkUpdatePermissions :batchmany
UPDATE permissions
SET title_ru = $2,
    title_en = $3,
    title_kk = $4,
    description_ru = $5,
    description_en = $6,
    description_kk = $7,
    value = $8,
    updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title_ru, title_en, title_kk, description_ru, description_kk, description_en, value, created_at, updated_at, deleted_at
`

type BulkUpdatePermissionsBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type BulkUpdatePermissionsParams struct {
	ID            pgtype.UUID `json:"id"`
	TitleRu       string      `json:"title_ru"`
	TitleEn       pgtype.Text `json:"title_en"`
	TitleKk       pgtype.Text `json:"title_kk"`
	DescriptionRu string      `json:"description_ru"`
	DescriptionEn pgtype.Text `json:"description_en"`
	DescriptionKk pgtype.Text `json:"description_kk"`
	Value         string      `json:"value"`
}

func (q *Queries) BulkUpdatePermissions(ctx context.Context, arg []BulkUpdatePermissionsParams) *BulkUpdatePermissionsBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.TitleRu,
			a.TitleEn,
			a.TitleKk,
			a.DescriptionRu,
			a.DescriptionEn,
			a.DescriptionKk,
			a.Value,
		}
		batch.Queue(bulkUpdatePermissions, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &BulkUpdatePermissionsBatchResults{br, len(arg), false}
}

func (b *BulkUpdatePermissionsBatchResults) Query(f func(int, []Permission, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		items := []Permission{}
		if b.closed {
			if f != nil {
				f(t, items, ErrBatchAlreadyClosed)
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			if err != nil {
				return err
			}
			defer rows.Close()
			for rows.Next() {
				var i Permission
				if err := rows.Scan(
					&i.ID,
					&i.TitleRu,
					&i.TitleEn,
					&i.TitleKk,
					&i.DescriptionRu,
					&i.DescriptionKk,
					&i.DescriptionEn,
					&i.Value,
					&i.CreatedAt,
					&i.UpdatedAt,
					&i.DeletedAt,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *BulkUpdatePermissionsBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const bulkUpdateRoles = `-- name: BulkUpdateRoles :batchmany
UPDATE roles
SET title_ru = $2,
    title_en = $3,
    title_kk = $4,
    description_ru = $5,
    description_en = $6,
    description_kk = $7,
    value = $8,
    updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, title_ru, title_en, title_kk, description_ru, description_kk, description_en, value, created_at, updated_at, deleted_at
`

type BulkUpdateRolesBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type BulkUpdateRolesParams struct {
	ID            pgtype.UUID `json:"id"`
	TitleRu       string      `json:"title_ru"`
	TitleEn       pgtype.Text `json:"title_en"`
	TitleKk       pgtype.Text `json:"title_kk"`
	DescriptionRu string      `json:"description_ru"`
	DescriptionEn pgtype.Text `json:"description_en"`
	DescriptionKk pgtype.Text `json:"description_kk"`
	Value         string      `json:"value"`
}

func (q *Queries) BulkUpdateRoles(ctx context.Context, arg []BulkUpdateRolesParams) *BulkUpdateRolesBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.TitleRu,
			a.TitleEn,
			a.TitleKk,
			a.DescriptionRu,
			a.DescriptionEn,
			a.DescriptionKk,
			a.Value,
		}
		batch.Queue(bulkUpdateRoles, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &BulkUpdateRolesBatchResults{br, len(arg), false}
}

func (b *BulkUpdateRolesBatchResults) Query(f func(int, []Role, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		items := []Role{}
		if b.closed {
			if f != nil {
				f(t, items, ErrBatchAlreadyClosed)
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			if err != nil {
				return err
			}
			defer rows.Close()
			for rows.Next() {
				var i Role
				if err := rows.Scan(
					&i.ID,
					&i.TitleRu,
					&i.TitleEn,
					&i.TitleKk,
					&i.DescriptionRu,
					&i.DescriptionKk,
					&i.DescriptionEn,
					&i.Value,
					&i.CreatedAt,
					&i.UpdatedAt,
					&i.DeletedAt,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *BulkUpdateRolesBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
